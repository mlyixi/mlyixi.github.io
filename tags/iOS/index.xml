<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>iOS on mlyixi的博客</title><link>https://mlyixi.github.io/tags/iOS/</link><description>Recent content in iOS on mlyixi的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 25 Dec 2014 17:08:52 +0800</lastBuildDate><atom:link href="https://mlyixi.github.io/tags/iOS/index.xml" rel="self" type="application/rss+xml"/><item><title>Xcode插件管理</title><link>https://mlyixi.github.io/post/osx/Xcode%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</link><pubDate>Thu, 25 Dec 2014 17:08:52 +0800</pubDate><guid>https://mlyixi.github.io/post/osx/Xcode%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</guid><description>插件也要包管理(Alcatraz) 之前(一年前吧), 关注了下Xcode插件,但是看到其包管理软件Alcatraz还在更新中,所以就没安装了.今天突然想起插件的事,就去看了下,果断支持最新版Xcode了.果断安装: 1 curl -fsSL https://raw.github.com/supermarin/Alcatraz/master/Scripts/install.sh | sh VVDocumenter 文档是一件麻烦事,果断选用VVDocumenter吧,</description></item><item><title>Xcode6.1下ios8.1免证书真机调试</title><link>https://mlyixi.github.io/post/osx/Xcode6.1%E4%B8%8Bios8.1%E5%85%8D%E8%AF%81%E4%B9%A6%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/</link><pubDate>Sat, 30 Aug 2014 18:08:52 +0800</pubDate><guid>https://mlyixi.github.io/post/osx/Xcode6.1%E4%B8%8Bios8.1%E5%85%8D%E8%AF%81%E4%B9%A6%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/</guid><description>iOS9开始已经允许开发者创建免费证书进行真机调试了. 一个必要条件是机器必需为越狱且装有appsync,不然不能运行. 现在appsync for iOS 8 还是beta阶段,但也可以用了,具体见官方说明. 对于低版本的xcode其实有一个比较方便的软件:JailCoder,可惜作者不更新了. 自己</description></item><item><title>Xcode子工程及cocoapods管理</title><link>https://mlyixi.github.io/post/osx/Xcode%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%8F%8Acocoapods%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 30 Aug 2014 17:08:52 +0800</pubDate><guid>https://mlyixi.github.io/post/osx/Xcode%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%8F%8Acocoapods%E7%AE%A1%E7%90%86/</guid><description>iOS应用总会用到很多库,而苹果只允许使用第三方的静态库.所以,开发者不能制作简单的framework供其它开发者调用. 而且,静态库加入到自己的工程也是个比较麻烦的事情,特别是有些工程没有制作静态库的target,这时还要自己制作静态库目标. 自定义静态库 新建自己的工程,git化.</description></item><item><title>iOS视图控制器初始化总结</title><link>https://mlyixi.github.io/post/osx/iOS%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 27 Aug 2014 18:08:52 +0800</pubDate><guid>https://mlyixi.github.io/post/osx/iOS%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E6%80%BB%E7%BB%93/</guid><description>首先,区别viewcontroller初始化的三种方式:完全代码化,半代码化初始和IB初始的区别 代码化:完全没有Xib之类的东西,通过纯代码实现加载. 半代码化:设计xib,然后在程序中用代码调用xib来初始化. 完全IB化:设计xib之类,然后加入到其它xib里.如MainWind</description></item><item><title>iOS完全代码化开发</title><link>https://mlyixi.github.io/post/osx/iOS%E5%AE%8C%E5%85%A8%E4%BB%A3%E7%A0%81%E5%8C%96%E5%BC%80%E5%8F%91/</link><pubDate>Wed, 27 Aug 2014 16:08:52 +0800</pubDate><guid>https://mlyixi.github.io/post/osx/iOS%E5%AE%8C%E5%85%A8%E4%BB%A3%E7%A0%81%E5%8C%96%E5%BC%80%E5%8F%91/</guid><description>视图 把自定义视图控制器赋给Delegation-window-rootViewController，在自定义视图控制器的loadView方法中初始化view. NOIBDelegation.h 1 2 3 @class NOIBViewController; @property (strong, nonatomic) NOIBViewController *viewController; NOIBAppDelegate.m &amp;ndash; didFinishLaunchingWithOptions: 1 self.window.rootViewController = viewController; NOIBViewController.h 1 @property (strong, nonatomic) UILabel *label; NOIBViewController.m 1 2 3 4 5 6 7 8 9 10 - (void)loadView { CGRect frame = CGRectMake(0, 0, 320, 480); self.view = [[UIView alloc] initWithFrame:frame]; self.view.backgroundColor = [UIColor whiteColor]; frame = CGRectMake(0, 0, 100, 50);</description></item><item><title>iOSframe和bound的理解</title><link>https://mlyixi.github.io/post/osx/iOSframe%E5%92%8Cbound%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Wed, 27 Aug 2014 14:08:52 +0800</pubDate><guid>https://mlyixi.github.io/post/osx/iOSframe%E5%92%8Cbound%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>翻译自此文 在iOS中,viewController是一个控制view层次的对象.主要负责MVC中Model和View之间的交互. viewController中有一个根视图self.view. self.view的范围是从状态栏下面到属于该控制器的下界(iOS7中已经改成透明状态栏了</description></item></channel></rss>